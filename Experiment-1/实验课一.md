[TOC]

# 理解函数实现过程

* 可以调函数
* 理解函数过程实现、数据的形式的变化(取整、四舍五入等)

# 实验目的

* 熟悉$Matlab$ 图像处理编程环境
* 图像$JPEG$ 压缩实验

# 实验内容

## 模拟数字图像$JPEG$压缩，绘制$PSNR$~$Q$曲线

峰值信噪比（随Q的变化而变化，0到100组）纵轴PSNR，横轴Q->Matlab plot 

（调用自带函数）

imagewrite

对原始的、无失真图像（老师给的标准图像）

几个参数：质量因子

PSNR：衡量图像的质量、任意一个压缩后的图像和原始图像



## 显示压缩前后的灰度直方图，观察并分析所存在的差异

- hist算矩阵直方图->建议仔细研究，对之后的数组用bar绘制直方图

- imhist 用之前搞明白、很复杂，要求自变量是什么类型，取值范围，有一个默认的取值（要理解后用）

  建议Q为70 

  显示具体的测试图

## 读取JPEG图像文件

自己编程解码提取第$x$（学号后两位）个宏块的量化后$DCT$系数、模拟反量化和逆DCT变换，恢复并显示对应空域图像块，观察并分析$JPEG$压缩引起的块效应

  8*8像素的小块

huffman逆回去，得到量化后的$DCT$系数，模拟反量化和逆$DCT$变换

* imread 得到的是图像文件的空域块 和自己模拟得到的空域块是否一样 

`马赛克效应`

自动检测和自动计算 块效应，随着Q的变化



readfile 读文件

从码流读出AC、DC系数的量化表、AC和DC系数抽取、huffman编码、、、、

解析底层的码流



学习资料：Jessica Fridrich

download http://dde.binghamton.edu/download/

research code

nsf5

 

# 实验报告

描述实验过程、测试数据、实验结果



# 实验

jpegread和jpegwrite的链接

mex C语言的子函数在matlab下调用 混合编译的



没有强调是彩色图像还是灰度图像，考虑`灰度图像`的$JPEG$压缩

给的是彩图，先转换为灰度图像（调函数）

```matlab
dictionary ='C:\Users\cg\Desktop\LP\LP\lp_image\';%'D:\数据集2.0\P\';
sub_dictionary = dir(dictionary);
%% process each image orderly
    k =0; 
for i = 3:size(sub_dictionary,1)  
    k = k + 1; 
    disp(strcat(num2str(k),'/',num2str(size(sub_dictionary,1)-2)))
    path_image = strcat(dictionary,sub_dictionary(i).name);
    im0 = double(imread(path_image)); 
    dimIm = ndims(im0);
    if dimIm == 3  
       imRgb = rgb2ntsc(im0);  % output float  
       im0 = imRgb(:,:,1);    % original image - value(luminance) channel
    end
    figure,imshow(uint8(im0)),colormap('gray')
```

图像的批处理

颜色空间的转换：`rgb2ntsc`  rgb2gray容易出问题

​	取第一个矩阵，取出亮度通道，对应的灰度图像



clc、clear、close all



matlab左边	设断点

写清楚注释文件



```matlab

% Load the cover image 载入图像
I = imread('lena256.png'); %图片在文件夹下，用相对路径
figure('name','Original image'), imshow(I)

% Convert to grayscale [0,255] image
G = rgb2gray(I); %不建议用
[rows, cols] = size(G);
figure('name','Grayscale image'), imshow(G)

%-------------------------------------------------------------------------%
% 1. SEPARATE EACH BITPLANE OF THE INPUT IMAGE                            %
%-------------------------------------------------------------------------%

% Initialise the cube container 比特面
planes = zeros(rows,cols,8);

% The slow way: convert each pixel of the image to its binary value, which
% is represented as a string. Place each element of the string in the right
% slice of the bitplane matrix 生成比特面
for i=1:size(G,1)
    for j=1:size(G,2)
        binaryPixel = dec2bin( G(i,j) );
        
        % the last element of the string goes in the last slice of the
        % matrix and so on
        k=0;
        for b=length(binaryPixel):-1:1
            planes(i,j,8-k) = str2double( binaryPixel(b) );
            k = k+1;
        end
        
    end
end

% Display each bitplane separately 显示比特面
for i=1:8
    figure('name',['Bitplane ' num2str(i)]), imshow(planes(:,:,i));
end


%-------------------------------------------------------------------------%
% 2. RECONSTRUCT THE INPUT IMAGE FROM BITPLANES                           %
%-------------------------------------------------------------------------%
% 利用比特面重构图像
G_rec = zeros(size(planes,1),size(planes,2));

for i=1:size(planes,1)
    for j=1:size(planes,2)
        
        % Select all the bits of the current pixel
        binaryPixel = planes(i,j,:);
        binaryPixel = reshape(binaryPixel,1,length(binaryPixel),1);
        
        % Order them from the LSB to the MSB
        binaryPixel = binaryPixel(end:-1:1);
        
        % Convert the array to the corresponding decimal value
        G_rec(i,j) = bi2de(binaryPixel);
    end
end
G_rec = uint8(G_rec);
figure('name','Original vs reconstructed'),
subplot(1,2,1),imshow(G);
subplot(1,2,2),imshow(G_rec);


%-------------------------------------------------------------------------%
% 3. MANIPULATE THE SUBPLANES 8,4,1 AND RECONSTRUCT THE INITIAL IMAGE     %
%-------------------------------------------------------------------------%

to_change = [8,4,1];

% For each bitplane to modify (separately)
for p=1:numel(to_change)
    
    % Set the chosen subplane to 0
    planes(:,:, to_change(p) ) = zeros(rows,cols);
    G_rec = zeros(size(planes,1),size(planes,2));
    
    % Reconstruct
    for i=1:size(planes,1)
        for j=1:size(planes,2)
            binaryPixel = planes(i,j,:);
            binaryPixel = reshape(binaryPixel,1,length(binaryPixel),1);
            binaryPixel = binaryPixel(end:-1:1);
            G_rec(i,j) = bi2de(binaryPixel);
        end
    end
    G_rec = uint8(G_rec);
    
    % Display
    figure('Name',['Bitplane' num2str( to_change(p) ) ' set to 0']),
    subplot(1,2,1),imshow(G), title('Original');
    subplot(1,2,2),imshow(G_rec), title('Modified');

end
```



```matlab
clc
clear
close all
im=imread('C:\Users\65476\Desktop\lena512.bmp');
figure(1),subplot(1,3,1),imshow(im),title('原始图像')
imNois1 = imnoise(im,'gaussian',0,0.005);
figure(1),subplot(1,3,2),imshow(imNois1),title('高斯噪声干扰')
imNois2 = imnoise(im,'salt & pepper',0.1);
figure(1),subplot(1,3,3),imshow(imNois2),title('椒盐噪声干扰')

%% 均值滤波后
% % figure(11),subplot(2,3,1),imshow(imNois1),title('高斯噪声干扰')
% % imNois11 = imfilter(imNois1,ones(3,3)/9);
% % figure(11),subplot(2,3,2),imshow(imNois11),title('3x3 均值滤波')
% % imNois11 = imfilter(imNois1,ones(5,5)/25);
% % figure(11),subplot(2,3,3),imshow(imNois11),title('5x5 均值滤波')
% % imNois11 = imfilter(imNois1,ones(7,7)/49);
% % figure(11),subplot(2,3,4),imshow(imNois11),title('7x7 均值滤波')
% % imNois11 = imfilter(imNois1,ones(9,9)/81);
% % figure(11),subplot(2,3,5),imshow(imNois11),title('9x9 均值滤波')
% % H=[1 2 1;2 4 2;1 2 1]/16;
% % imNois11 = imfilter(imNois1,H);
% % figure(11),subplot(2,3,6),imshow(imNois11),title('3x3 加权均值滤波')
% 
% figure(11),subplot(1,3,1),imshow(imNois1),title('高斯噪声干扰')
% imNois11 = imfilter(imNois1,ones(3,3)/9);
% figure(11),subplot(1,3,2),imshow(imNois11),title('3x3 均值滤波')
% imNois11 = imfilter(imNois1,ones(5,5)/25);
% figure(11),subplot(1,3,3),imshow(imNois11),title('5x5 均值滤波')
% imNois11 = imfilter(imNois1,ones(7,7)/49);
% figure(12),subplot(1,3,1),imshow(imNois11),title('7x7 均值滤波')
% imNois11 = imfilter(imNois1,ones(9,9)/81);
% figure(12),subplot(1,3,2),imshow(imNois11),title('9x9 均值滤波')
% H=[1 2 1;2 4 2;1 2 1]/16;
% imNois11 = imfilter(imNois1,H);
% figure(12),subplot(1,3,3),imshow(imNois11),title('3x3 加权均值滤波')

%% 中值滤波后
figure(22),subplot(1,3,1),imshow(imNois2),title('椒盐噪声干扰')
imNois22 = uint8(filter_median(imNois2,1));%[im_med] = filter_median(im,radius)
figure(22),subplot(1,3,2),imshow(imNois22),title('3x3 中值滤波')
imNois22 = uint8(filter_median(imNois2,2));%[im_med] = filter_median(im,radius)
figure(22),subplot(1,3,3),imshow(imNois22),title('5x5 中值滤波')

imNois22 = uint8(filter_median(imNois2,3));%[im_med] = filter_median(im,radius)
figure(23),subplot(1,3,1),imshow(imNois22),title('7x7 中值滤波')
imNois22 = imfilter(imNois2,ones(3,3)/9);
figure(23),subplot(1,3,2),imshow(imNois22),title('3x3 均值滤波')
imNois22 = imfilter(imNois2,ones(5,5)/25);
figure(23),subplot(1,3,3),imshow(imNois22),title('5x5 均值滤波')
```

